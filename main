#!/usr/bin/env ruby

require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'securerandom'
require 'rack/protection'
require_relative './helpers'
require_relative './models'

set :database, { adapter: 'postgresql', encoding: 'unicode', pool: 2, url: ENV['DATABASE_URL'] }
set :bind, '0.0.0.0'
set :port, 3000
set :sessions, true
set :session_secret, ENV['SESSION_SECRET']
set :strict_paths, false

use Rack::Protection::AuthenticityToken, allow_if: ->(env) {
  env['PATH_INFO'].start_with?('/auth/developer/callback') ||
    env['PATH_INFO'].start_with?('/auth/google/callback')
}

use OmniAuth::Builder do
  provider :developer if development?
  provider :google_oauth2, ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']
end

get '/' do
  loggedin? ? redirect("/users/#{current_user.slug}") : erb(:index, locals: { user: nil })
end

get '/users/:user' do
  user = User.find_by!(slug: params[:user])
  erb :'users/show', locals: { user: user, books: user.books.where.missing(:shelf), shelves: user.shelves }
end

get '/users/:user/edit' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :edit, user
  erb :'users/edit', locals: { user: user }
end

post '/users/:user' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :edit, user

  attrs = params.slice(:description, *User::PROFILES)
  if user.update(attrs)
    redirect "/users/#{user.slug}"
  else
    erb :'users/edit', locals: { user: user }
  end
end

get '/users/:user/books/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.books.new
  erb :'books/new', locals: { user: user, book: user.books.new }
end

post '/users/:user/books' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:title, :author, :isbn)
  book = user.books.new(attrs)
  halt 401 unless can? :create, book

  if book.save
    redirect "/users/#{user.slug}/books/#{book.isbn}/image"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  erb :'books/show', locals: { user: user, book: book }
end

get '/users/:user/books/:isbn/edit' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/new', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  attrs = params.slice(:title, :author)
  if book.update(attrs)
    redirect "/users/#{user.slug}/books/#{book.isbn}"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/image', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  size = FastImage.size(params[:image][:tempfile])
  allowed_type = [:gif, :png, :jpeg].include? FastImage.type(params[:image][:tempfile])

  book.errors.add(:image, 'File type is not an image. Allowed type JPG, GIF, PNG') unless allowed_type
  book.errors.add(:image, 'Image should be a portrait. width should be less than height') if size && size[0] > size[1]
  return erb :'books/image', locals: { user: user, book: book } if book.errors.include?(:image)

  (File.delete("public/books/image/#{book.image}") rescue nil) if book.image
  book.update(image: SecureRandom.uuid)
  FileUtils.mv params[:image][:tempfile], "public/books/image/#{book.image}"

  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/shelf' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  shelf = params[:shelf_id].empty? ? nil : user.shelves.find(params[:shelf_id])
  halt 401 unless can? :edit, shelf if shelf

  book.update(shelf: shelf)
  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/borrows' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :borrow, book

  book.borrows.create(user: current_user, owner: book.user, days: params[:days])

  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/borrows/:borrow/borrow' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.wait_list.find(params[:borrow])
  halt 401 unless can? :borrow, borrow

  borrow.update(borrowed_at: Time.now)

  redirect back
end

post '/users/:user/books/:isbn/borrows/:borrow/return' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.borrowed.find(params[:borrow])
  halt 401 unless can? :return, borrow

  borrow.update(returned_at: Time.now)

  redirect back
end

delete '/users/:user/books/:isbn/borrows/:borrow' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.find(params[:borrow])
  halt 401 unless can? :delete, borrow

  borrow.destroy

  redirect back
end

delete '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :delete, book

  book.destroy
  redirect '/'
end

get '/users/:user/shelves/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.shelves.new

  erb :'shelves/new', locals: { user: user, shelf: user.shelves.new }
end

post '/users/:user/shelves' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:name)
  shelf = user.shelves.new(attrs)
  halt 401 unless can? :create, shelf

  if shelf.save
    redirect '/'
  else
    erb :'shelves/new', locals: { user: user, shelf: shelf }
  end
end

get '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])

  erb :'shelves/show', locals: { user: user, shelf: shelf }
end

get '/users/:user/shelves/:shelf/edit' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  erb :'shelves/edit', locals: { user: user, shelf: shelf }
end

post '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  attrs = params.slice(:name)
  shelf.update(attrs)

  redirect "/users/#{user.slug}/shelves/#{shelf.id}"
end

post '/users/:user/shelves/:shelf/up' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_higher
  redirect '/'
end

post '/users/:user/shelves/:shelf/down' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_lower
  redirect '/'
end

delete '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :delete, shelf

  shelf.destroy
  redirect '/'
end

post '/auth/:provider/callback' do
  halt if params[:provider] == 'developer' && !settings.development?

  info = request.env['omniauth.auth']['info']
  attrs = info.slice(:name, :email, :image).to_h
  attrs[:slug] = SecureRandom.uuid
  user = User.create_with(attrs).find_or_create_by(email: attrs['email'])
  session[:user] = user.id

  redirect(env['omniauth.origin'] || '/')
end

get '/logout' do
  halt 401 unless can? :logout

  session[:user] = nil
  redirect '/'
end

post '/users/:user/accesses' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.new(user: current_user)
  halt 401 unless can? :create, access

  access.save
  redirect back
end

post '/users/:user/accesses/:access/accept' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :accept, access

  access.update(accepted_at: Time.now)
  redirect back
end

post '/users/:user/accesses/:access/reject' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :reject, access

  access.update(rejected_at: Time.now)
  redirect back
end

delete '/users/:user/accesses/:access' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :delete, access

  access.destroy
  redirect back
end

get '/accesses/from' do
  user = current_user
  halt 401 unless can? :list_access

  erb :'accesses/from', locals: { accesses: current_user.accesses_from, user: user }
end

get '/accesses/to' do
  user = current_user
  halt 401 unless can? :list_access

  erb :'accesses/to', locals: { accesses: current_user.accesses_to, user: user }
end

get '/books/to_lend' do
  user = current_user
  halt 401 unless can? :to_lend

  erb :'books/to_lend', locals: { user: user, books: user.books_to_lend }
end

get '/books/to_borrow' do
  user = current_user
  halt 401 unless can? :to_borrow

  erb :'books/to_borrow', locals: { user: user, books: user.books_to_borrow }
end
