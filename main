#!/usr/bin/env ruby

require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'securerandom'
require 'rack/protection'
require_relative './helpers'
require_relative './models'

set :database, { adapter: 'sqlite3', database: "#{settings.environment}.sqlite3" }
set :bind, '0.0.0.0'
set :port, 3000
set :sessions, true
set :session_secret, ENV['SESSION_SECRET']
set :strict_paths, false

use Rack::Protection::AuthenticityToken, allow_if: ->(env) {
  env['PATH_INFO'].start_with?('/auth/developer/callback') ||
    env['PATH_INFO'].start_with?('/auth/google/callback')
}

use OmniAuth::Builder do
  provider :developer if development?
  provider :google_oauth2, ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']
end

get '/' do
  loggedin? ? redirect("/users/#{current_user.slug}") : erb(:index, locals: { user: nil })
end

get '/users/:user' do
  user = User.find_by!(slug: params[:user])
  erb :'users/show', locals: { user: user, books: user.books.where.missing(:shelf), shelves: user.shelves }
end

get '/users/:user/books/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.books.new
  erb :'books/new', locals: { user: user, book: user.books.new }
end

post '/users/:user/books' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:title, :author, :isbn)
  book = user.books.new(attrs)
  halt 401 unless can? :create, book

  if book.save
    redirect "/users/#{user.slug}/books/#{book.isbn}/image"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  erb :'books/show', locals: { user: user, book: book }
end

get '/users/:user/books/:isbn/edit' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/new', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  attrs = params.slice(:title, :author)
  if book.update(attrs)
    redirect "/users/#{user.slug}/books/#{book.isbn}"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/image', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  size = FastImage.size(params[:image][:tempfile])
  allowed_type = [:gif, :png, :jpeg].include? FastImage.type(params[:image][:tempfile])

  book.errors.add(:image, 'File type is not an image. Allowed type JPG, GIF, PNG') unless allowed_type
  book.errors.add(:image, 'Image should be a portrait. width should be less than height') if size && size[0] > size[1]
  return erb :'books/image', locals: { user: user, book: book } if book.errors.include?(:image)

  (File.delete("public/books/image/#{book.image}") rescue nil) if book.image
  book.update(image: SecureRandom.uuid)
  FileUtils.mv params[:image][:tempfile], "public/books/image/#{book.image}"

  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/shelf' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  shelf = user.shelves.find(params[:shelf_id])
  halt 401 unless can? :edit, shelf

  book.update(shelf: shelf)
  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

delete '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :delete, book

  book.destroy
  redirect '/'
end

get '/users/:user/shelves/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.shelves.new

  erb :'shelves/new', locals: { user: user, shelf: user.shelves.new }
end

post '/users/:user/shelves' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:name)
  shelf = user.shelves.new(attrs)
  halt 401 unless can? :create, shelf

  if shelf.save
    redirect '/'
  else
    erb :'shelves/new', locals: { user: user, shelf: shelf }
  end
end

get '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])

  erb :'shelves/show', locals: { user: user, shelf: shelf }
end

get '/users/:user/shelves/:shelf/edit' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  erb :'shelves/edit', locals: { user: user, shelf: shelf }
end

post '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  attrs = params.slice(:name)
  shelf.update(attrs)

  redirect "/users/#{user.slug}/shelves/#{shelf.id}"
end

post '/users/:user/shelves/:shelf/up' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_higher
  redirect '/'
end

post '/users/:user/shelves/:shelf/down' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_lower
  redirect '/'
end

delete '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :delete, shelf

  shelf.destroy
  redirect '/'
end

post '/auth/:provider/callback' do
  halt if params[:provider] == 'developer' && !settings.development?

  info = request.env['omniauth.auth']['info']
  attrs = info.slice(:name, :email, :image).to_h
  attrs[:slug] = SecureRandom.uuid
  user = User.create_with(attrs).find_or_create_by(email: attrs['email'])
  session[:user] = user.id

  redirect '/'
end

get '/logout' do
  halt 401 unless can? :logout

  session[:user] = nil
  redirect '/'
end
