#!/usr/bin/env ruby

require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'securerandom'
require 'rack/protection'
require_relative './helpers'
require_relative './models'

set :database, { adapter: 'sqlite3', database: "#{settings.environment}.sqlite3" }
set :bind, '0.0.0.0'
set :port, 3000
set :sessions, true
set :session_secret, ENV['SESSION_SECRET']
set :strict_paths, false

use Rack::Protection::AuthenticityToken, allow_if: ->(env) {
  env['PATH_INFO'].start_with?('/auth/developer/callback') ||
    env['PATH_INFO'].start_with?('/auth/google/callback')
}

use OmniAuth::Builder do
  provider :developer if development?
  provider :google_oauth2, ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']
end

get '/' do
  erb :index, locals: { books: Book.where.missing(:shelf), shelves: Shelf.all }
end

get '/books/new' do
  halt 401 unless can? :create, Book.new
  erb :'books/new', locals: { book: Book.new }
end

post '/books' do
  attrs = params.slice(:title, :author, :isbn)
  book = Book.new(attrs)
  halt 401 unless can? create, book

  book.save ? redirect("/books/#{book.isbn}/image") : erb(:'books/new', locals: { book: book })
end

get '/books/:isbn' do
  book = Book.find_by!(isbn: params[:isbn])
  erb :'books/show', locals: { book: book }
end

get '/books/:isbn/edit' do
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/new', locals: { book: book }
end

post '/books/:isbn' do
  attrs = params.slice(:title, :author)
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  book.update(attrs) ? redirect("/books/#{book.isbn}") : erb(:'books/new', locals: { book: book })
end

get '/books/:isbn/image' do
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/image', locals: { book: book }
end

post '/books/:isbn/image' do
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  size = FastImage.size(params[:image][:tempfile])
  allowed_type = [:gif, :png, :jpeg].include? FastImage.type(params[:image][:tempfile])

  book.errors.add(:image, 'File type is not an image. Allowed type JPG, GIF, PNG') unless allowed_type
  book.errors.add(:image, 'Image should be a portrait. width should be less than height') if size && size[0] > size[1]
  return erb :'books/image', locals: { book: book } if book.errors.include?(:image)

  (File.delete("public/books/image/#{book.image}") rescue nil) if book.image
  book.update(image: SecureRandom.uuid)
  FileUtils.mv params[:image][:tempfile], "public/books/image/#{book.image}"

  redirect "/books/#{book.isbn}"
end

post '/books/:isbn/shelf' do
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  book.update(shelf_id: params[:shelf_id])

  redirect "/books/#{book.isbn}"
end

delete '/books/:isbn' do
  book = Book.find_by!(isbn: params[:isbn])
  halt 401 unless can? :delete, book

  book.destroy
  redirect '/'
end

get '/shelves/new' do
  halt 401 unless can? :create, Shelf.new

  erb :'shelves/new', locals: { shelf: Shelf.new }
end

post '/shelves' do
  attrs = params.slice(:name)
  shelf = Shelf.new(attrs)
  halt 401 unless can? :create, shelf

  shelf.save ? redirect('/') : erb(:'shelves/new', locals: { shelf: shelf })
end

get '/shelves/:id' do
  shelf = Shelf.find(params[:id])
  erb :'shelves/show', locals: { shelf: shelf }
end

get '/shelves/:id/edit' do
  shelf = Shelf.find(params[:id])
  halt 401 unless can? :edit, shelf

  erb :'shelves/edit', locals: { shelf: shelf }
end

post '/shelves/:id' do
  shelf = Shelf.find(params[:id])
  halt 401 unless can? :edit, shelf

  attrs = params.slice(:name)
  shelf.update(attrs)

  redirect "/shelves/#{shelf.id}"
end

delete '/shelves/:id' do
  shelf = Shelf.find(params[:id])
  halt 401 unless can? :delete, shelf

  shelf.destroy
  redirect '/'
end

post '/auth/:provider/callback' do
  halt if params[:provider] == 'developer' && !settings.development?

  info = request.env['omniauth.auth']['info']
  attrs = info.slice(:name, :email, :image).to_h
  user = User.create_with(attrs).find_or_create_by(email: attrs['email'])
  session[:user] = user.id

  redirect '/'
end

get '/logout' do
  halt 401 unless can? :logout

  session[:user] = nil
  redirect '/'
end
