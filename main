#!/usr/bin/env ruby

require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'securerandom'
require 'rack/protection'
require_relative './helpers'
require_relative './models'

set :database, { adapter: 'postgresql', encoding: 'unicode', pool: 5, url: ENV['DATABASE_URL'] }
set :bind, '0.0.0.0'
set :port, 3000
set :sessions, true
set :session_secret, ENV['SESSION_SECRET']
set :strict_paths, false
set :static_cache_control, [:public, { max_age: 60 * 60 * 24 * 365 }]

use Rack::Protection::AuthenticityToken, allow_if: ->(env) {
  env['PATH_INFO'].start_with?('/auth/developer/callback')
}

use OmniAuth::Builder do
  provider :developer if development?
  provider :google_oauth2, ENV['GOOGLE_CLIENT_ID'], ENV['GOOGLE_CLIENT_SECRET']
end

get '/' do
  loggedin? ? redirect("/users/#{current_user.slug}") : erb(:index, locals: { user: nil })
end

get '/users/:user' do
  user = User.find_by!(slug: params[:user])
  @title = user.name
  erb :'users/show', locals: { user: user, books: user.books.where.missing(:shelf), shelves: user.shelves }
end

get '/users/:user/edit' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :edit, user

  erb :'users/edit', locals: { user: user }
end

post '/users/:user' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :edit, user

  attrs = params.slice(:description, *User::PROFILES)
  if user.update(attrs)
    redirect "/users/#{user.slug}"
  else
    erb :'users/edit', locals: { user: user }
  end
end

get '/users/:user/books/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.books.new

  erb :'books/new', locals: { user: user, book: user.books.new }
end

post '/users/:user/books' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:title, :author, :isbn, :google_books_id, :subtitle, :description, :page_count, :publisher)
  book = user.books.new(attrs)
  halt 401 unless can? :create, book

  if book.save
    redirect "/users/#{user.slug}/books/#{book.isbn}"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  @title = book.title

  set_meta("og:title", book.title)
  set_meta(:author, book.author)
  set_meta(:description, book.description)
  set_meta("og:description", book.description)
  set_meta("og:type", "article")
  set_meta("og:image", book_cover(book) )
  set_meta("twitter:image", book_cover(book) )
  set_meta("twitter:card", "summary")
  set_meta("twitter:title", book.title)

  erb :'books/show', locals: { user: user, book: book }
end

get '/users/:user/books/:isbn/edit' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/new', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  attrs = params.slice(:title, :author, :google_books_id, :subtitle, :description, :page_count, :publisher)
  if book.update(attrs)
    redirect "/users/#{user.slug}/books/#{book.isbn}"
  else
    erb :'books/new', locals: { user: user, book: book }
  end
end

get '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  erb :'books/image', locals: { user: user, book: book }
end

post '/users/:user/books/:isbn/image' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  book.upload(params[:image][:tempfile])

  if book.invalid?
    erb :'books/image', locals: { user: user, book: book }
  else
    redirect "/users/#{user.slug}/books/#{book.isbn}"
  end
end

post '/users/:user/books/:isbn/shelf' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :edit, book

  shelf = params[:shelf_id].empty? ? nil : user.shelves.find(params[:shelf_id])
  halt 401 if shelf && !can?(:edit, shelf)

  book.update(shelf: shelf)
  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/borrows' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :borrow, book

  borrow = book.borrows.create(user: current_user, owner: book.user, days: params[:days])
  Email.create(user: user, emailable: borrow, about: :requested)

  redirect "/users/#{user.slug}/books/#{book.isbn}"
end

post '/users/:user/books/:isbn/borrows/:borrow/borrow' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.wait_list.find(params[:borrow])
  halt 401 unless can? :borrow, borrow

  borrow.update(borrowed_at: Time.now)

  redirect back
end

post '/users/:user/books/:isbn/borrows/:borrow/return' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.borrowed.find(params[:borrow])
  halt 401 unless can? :return, borrow

  borrow.update(returned_at: Time.now)

  redirect back
end

delete '/users/:user/books/:isbn/borrows/:borrow' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  borrow = book.borrows.find(params[:borrow])
  halt 401 unless can? :delete, borrow

  borrow.destroy

  redirect back
end

delete '/users/:user/books/:isbn' do
  user = User.find_by!(slug: params[:user])
  book = user.books.find_by!(isbn: params[:isbn])
  halt 401 unless can? :delete, book

  book.destroy
  redirect '/'
end

get '/users/:user/shelves/new' do
  user = User.find_by!(slug: params[:user])
  halt 401 unless can? :create, user.shelves.new

  erb :'shelves/new', locals: { user: user, shelf: user.shelves.new }
end

post '/users/:user/shelves' do
  user = User.find_by!(slug: params[:user])
  attrs = params.slice(:name)
  shelf = user.shelves.new(attrs)
  halt 401 unless can? :create, shelf

  if shelf.save
    redirect '/'
  else
    erb :'shelves/new', locals: { user: user, shelf: shelf }
  end
end

get '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])

  erb :'shelves/show', locals: { user: user, shelf: shelf }
end

get '/users/:user/shelves/:shelf/edit' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  erb :'shelves/edit', locals: { user: user, shelf: shelf }
end

post '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  attrs = params.slice(:name)
  shelf.update(attrs)

  redirect "/users/#{user.slug}/shelves/#{shelf.id}"
end

post '/users/:user/shelves/:shelf/up' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_higher
  redirect '/'
end

post '/users/:user/shelves/:shelf/down' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :edit, shelf

  shelf.move_lower
  redirect '/'
end

delete '/users/:user/shelves/:shelf' do
  user = User.find_by!(slug: params[:user])
  shelf = user.shelves.find(params[:shelf])
  halt 401 unless can? :delete, shelf

  shelf.destroy
  redirect '/'
end

post '/auth/developer/callback' do
  halt unless settings.development?

  info = request.env['omniauth.auth']['info']
  session[:user] = User.signup(info[:name], info[:email], info[:image]).id
  redirect(env['omniauth.origin'] || '/')
end

get '/auth/google_oauth2/callback' do
  info = request.env['omniauth.auth']['info']
  session[:user] = User.signup(info[:name], info[:email], info[:image]).id

  redirect(env['omniauth.origin'] || '/')
end

get '/logout' do
  halt 401 unless can? :logout

  session[:user] = nil
  redirect '/'
end

post '/users/:user/accesses' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.new(user: current_user)
  halt 401 unless can? :create, access

  access.save
  Email.create(user: user, emailable: access, about: :requested)

  redirect back
end

post '/users/:user/accesses/:access/accept' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :accept, access

  access.update(accepted_at: Time.now)
  Email.create(user: access.user, emailable: access, about: :accepted)

  redirect back
end

post '/users/:user/accesses/:access/reject' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :reject, access

  access.update(rejected_at: Time.now)
  redirect back
end

delete '/users/:user/accesses/:access' do
  user = User.find_by!(slug: params[:user])
  access = user.accesses_to.find(params[:access])
  halt 401 unless can? :delete, access

  access.destroy
  redirect back
end

get '/accesses/from' do
  user = current_user
  halt 401 unless can? :list_access

  erb :'accesses/from', locals: { accesses: current_user.accesses_from, user: user }
end

get '/accesses/to' do
  user = current_user
  halt 401 unless can? :list_access

  erb :'accesses/to', locals: { accesses: current_user.accesses_to, user: user }
end

get '/books/to_lend' do
  user = current_user
  halt 401 unless can? :to_lend

  erb :'books/to_lend', locals: { user: user, books: user.books_to_lend }
end

get '/books/to_borrow' do
  user = current_user
  halt 401 unless can? :to_borrow

  erb :'books/to_borrow', locals: { user: user, books: user.books_to_borrow }
end

get '/privacy' do
  user = current_user
  erb :privacy, locals: { user: user }
end
