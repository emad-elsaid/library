// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package main

import (
	"context"
	"database/sql"
	"time"
)

const bookByIsbnAndUser = `-- name: BookByIsbnAndUser :one
SELECT books.id, books.title, books.author, books.image, books.isbn, books.created_at, books.updated_at, books.shelf_id, books.user_id, books.google_books_id, books.subtitle, books.description, books.page_count, books.publisher, slug, shelves.name shelf_name
  FROM users, books
       LEFT JOIN shelves
           ON shelves.id = books.shelf_id
 WHERE users.id = books.user_id
   AND books.user_id = $1
   AND isbn = $2
 LIMIT 1
`

type BookByIsbnAndUserParams struct {
	UserID int64
	Isbn   string
}

type BookByIsbnAndUserRow struct {
	ID            int64
	Title         string
	Author        string
	Image         sql.NullString
	Isbn          string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ShelfID       sql.NullInt32
	UserID        int64
	GoogleBooksID sql.NullString
	Subtitle      string
	Description   string
	PageCount     int32
	Publisher     string
	Slug          string
	ShelfName     sql.NullString
}

func (q *Queries) BookByIsbnAndUser(ctx context.Context, arg BookByIsbnAndUserParams) (BookByIsbnAndUserRow, error) {
	row := q.db.QueryRowContext(ctx, bookByIsbnAndUser, arg.UserID, arg.Isbn)
	var i BookByIsbnAndUserRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Image,
		&i.Isbn,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShelfID,
		&i.UserID,
		&i.GoogleBooksID,
		&i.Subtitle,
		&i.Description,
		&i.PageCount,
		&i.Publisher,
		&i.Slug,
		&i.ShelfName,
	)
	return i, err
}

const highlightByIDAndBook = `-- name: HighlightByIDAndBook :one
SELECT id, book_id, page, content, image, created_at, updated_at
  FROM highlights
 WHERE id = $1
   AND book_id = $2
 LIMIT 1
`

type HighlightByIDAndBookParams struct {
	ID     int64
	BookID int64
}

func (q *Queries) HighlightByIDAndBook(ctx context.Context, arg HighlightByIDAndBookParams) (Highlight, error) {
	row := q.db.QueryRowContext(ctx, highlightByIDAndBook, arg.ID, arg.BookID)
	var i Highlight
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Page,
		&i.Content,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const highlights = `-- name: Highlights :many
SELECT id, book_id, page, content, image, created_at, updated_at
  FROM highlights
 WHERE book_id = $1
`

func (q *Queries) Highlights(ctx context.Context, bookID int64) ([]Highlight, error) {
	rows, err := q.db.QueryContext(ctx, highlights, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Highlight
	for rows.Next() {
		var i Highlight
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Page,
			&i.Content,
			&i.Image,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newBook = `-- name: NewBook :one
INSERT INTO public.books (title, isbn, author, subtitle, description, publisher, page_count, google_books_id, user_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
       RETURNING id, title, author, image, isbn, created_at, updated_at, shelf_id, user_id, google_books_id, subtitle, description, page_count, publisher
`

type NewBookParams struct {
	Title         string
	Isbn          string
	Author        string
	Subtitle      string
	Description   string
	Publisher     string
	PageCount     int32
	GoogleBooksID sql.NullString
	UserID        int64
}

func (q *Queries) NewBook(ctx context.Context, arg NewBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, newBook,
		arg.Title,
		arg.Isbn,
		arg.Author,
		arg.Subtitle,
		arg.Description,
		arg.Publisher,
		arg.PageCount,
		arg.GoogleBooksID,
		arg.UserID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Image,
		&i.Isbn,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShelfID,
		&i.UserID,
		&i.GoogleBooksID,
		&i.Subtitle,
		&i.Description,
		&i.PageCount,
		&i.Publisher,
	)
	return i, err
}

const shelfBooks = `-- name: ShelfBooks :many
SELECT books.id id, title, books.image image, google_books_id, slug, isbn
  FROM books, users
 WHERE users.id = books.user_id
   AND shelf_id = $1
 ORDER BY books.created_at DESC
`

type ShelfBooksRow struct {
	ID            int64
	Title         string
	Image         sql.NullString
	GoogleBooksID sql.NullString
	Slug          string
	Isbn          string
}

func (q *Queries) ShelfBooks(ctx context.Context, shelfID sql.NullInt32) ([]ShelfBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, shelfBooks, shelfID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShelfBooksRow
	for rows.Next() {
		var i ShelfBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Image,
			&i.GoogleBooksID,
			&i.Slug,
			&i.Isbn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shelfByIdAndUser = `-- name: ShelfByIdAndUser :one
SELECT id, name, created_at, updated_at, user_id, position
  FROM shelves
 WHERE shelves.user_id = $1
   AND shelves.id = $2
 LIMIT 1
`

type ShelfByIdAndUserParams struct {
	UserID int64
	ID     int64
}

func (q *Queries) ShelfByIdAndUser(ctx context.Context, arg ShelfByIdAndUserParams) (Shelf, error) {
	row := q.db.QueryRowContext(ctx, shelfByIdAndUser, arg.UserID, arg.ID)
	var i Shelf
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Position,
	)
	return i, err
}

const shelves = `-- name: Shelves :many
SELECT id, name
  FROM shelves
 WHERE user_id = $1
 ORDER BY position
`

type ShelvesRow struct {
	ID   int64
	Name string
}

func (q *Queries) Shelves(ctx context.Context, userID int64) ([]ShelvesRow, error) {
	rows, err := q.db.QueryContext(ctx, shelves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShelvesRow
	for rows.Next() {
		var i ShelvesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signup = `-- name: Signup :one
INSERT
 INTO public.users(name, image, slug, email)
VALUES($1,$2,$3,$4)
       ON CONFLICT (email)
       DO UPDATE SET name = $1, image = $2
       RETURNING id
`

type SignupParams struct {
	Name  sql.NullString
	Image sql.NullString
	Slug  string
	Email sql.NullString
}

func (q *Queries) Signup(ctx context.Context, arg SignupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, signup,
		arg.Name,
		arg.Image,
		arg.Slug,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateBook = `-- name: UpdateBook :exec
UPDATE public.books
   SET title = $1,
       author = $2,
       subtitle = $3,
       description = $4,
       publisher = $5,
       page_count = $6
 WHERE id = $7
`

type UpdateBookParams struct {
	Title       string
	Author      string
	Subtitle    string
	Description string
	Publisher   string
	PageCount   int32
	ID          int64
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.ExecContext(ctx, updateBook,
		arg.Title,
		arg.Author,
		arg.Subtitle,
		arg.Description,
		arg.Publisher,
		arg.PageCount,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
   SET description = $1,
       amazon_associates_id = $2,
       facebook = $3,
       twitter = $4,
       linkedin = $5,
       instagram = $6,
       phone = $7,
       whatsapp = $8,
       telegram = $9
 WHERE id = $10
`

type UpdateUserParams struct {
	Description        sql.NullString
	AmazonAssociatesID sql.NullString
	Facebook           sql.NullString
	Twitter            sql.NullString
	Linkedin           sql.NullString
	Instagram          sql.NullString
	Phone              sql.NullString
	Whatsapp           sql.NullString
	Telegram           sql.NullString
	ID                 int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Description,
		arg.AmazonAssociatesID,
		arg.Facebook,
		arg.Twitter,
		arg.Linkedin,
		arg.Instagram,
		arg.Phone,
		arg.Whatsapp,
		arg.Telegram,
		arg.ID,
	)
	return err
}

const user = `-- name: User :one
SELECT id, name, email, image, created_at, updated_at, slug, description, facebook, twitter, linkedin, instagram, phone, whatsapp, telegram, amazon_associates_id
  FROM users
 WHERE id = $1
 LIMIT 1
`

func (q *Queries) User(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, user, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.Description,
		&i.Facebook,
		&i.Twitter,
		&i.Linkedin,
		&i.Instagram,
		&i.Phone,
		&i.Whatsapp,
		&i.Telegram,
		&i.AmazonAssociatesID,
	)
	return i, err
}

const userBySlug = `-- name: UserBySlug :one
SELECT id, name, email, image, created_at, updated_at, slug, description, facebook, twitter, linkedin, instagram, phone, whatsapp, telegram, amazon_associates_id
  FROM users
 WHERE slug = $1
 LIMIT 1
`

func (q *Queries) UserBySlug(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRowContext(ctx, userBySlug, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.Description,
		&i.Facebook,
		&i.Twitter,
		&i.Linkedin,
		&i.Instagram,
		&i.Phone,
		&i.Whatsapp,
		&i.Telegram,
		&i.AmazonAssociatesID,
	)
	return i, err
}

const userUnshelvedBooks = `-- name: UserUnshelvedBooks :many
SELECT books.id id, title, books.image image, google_books_id, slug, isbn
  FROM books, users
 WHERE users.id = books.user_id
   AND user_id = $1
   AND shelf_id IS NULL
`

type UserUnshelvedBooksRow struct {
	ID            int64
	Title         string
	Image         sql.NullString
	GoogleBooksID sql.NullString
	Slug          string
	Isbn          string
}

func (q *Queries) UserUnshelvedBooks(ctx context.Context, userID int64) ([]UserUnshelvedBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, userUnshelvedBooks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserUnshelvedBooksRow
	for rows.Next() {
		var i UserUnshelvedBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Image,
			&i.GoogleBooksID,
			&i.Slug,
			&i.Isbn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
