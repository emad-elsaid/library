// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package main

import (
	"context"
	"database/sql"
	"time"
)

const bookByIsbnAndUser = `-- name: BookByIsbnAndUser :one
SELECT books.id, books.title, books.author, books.image, books.isbn, books.created_at, books.updated_at, books.shelf_id, books.user_id, books.google_books_id, books.subtitle, books.description, books.page_count, books.publisher, slug, shelves.name shelf_name
  FROM users, books
       LEFT JOIN shelves
           ON shelves.id = books.shelf_id
 WHERE users.id = books.user_id
   AND books.user_id = $1
   AND isbn = $2
 LIMIT 1
`

type BookByIsbnAndUserParams struct {
	UserID int64
	Isbn   string
}

type BookByIsbnAndUserRow struct {
	ID            int64
	Title         string
	Author        string
	Image         sql.NullString
	Isbn          string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ShelfID       sql.NullInt32
	UserID        int64
	GoogleBooksID sql.NullString
	Subtitle      string
	Description   string
	PageCount     int32
	Publisher     string
	Slug          string
	ShelfName     sql.NullString
}

func (q *Queries) BookByIsbnAndUser(ctx context.Context, arg BookByIsbnAndUserParams) (BookByIsbnAndUserRow, error) {
	row := q.db.QueryRowContext(ctx, bookByIsbnAndUser, arg.UserID, arg.Isbn)
	var i BookByIsbnAndUserRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Image,
		&i.Isbn,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShelfID,
		&i.UserID,
		&i.GoogleBooksID,
		&i.Subtitle,
		&i.Description,
		&i.PageCount,
		&i.Publisher,
		&i.Slug,
		&i.ShelfName,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM public.books
 WHERE id = $1
`

func (q *Queries) DeleteBook(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBook, id)
	return err
}

const deleteHighlight = `-- name: DeleteHighlight :exec
DELETE FROM public.highlights
 WHERE id = $1
`

func (q *Queries) DeleteHighlight(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteHighlight, id)
	return err
}

const deleteShelf = `-- name: DeleteShelf :exec
DELETE FROM shelves
 WHERE id = $1
`

func (q *Queries) DeleteShelf(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteShelf, id)
	return err
}

const highlightByIDAndBook = `-- name: HighlightByIDAndBook :one
SELECT id, book_id, page, content, image, created_at, updated_at
  FROM highlights
 WHERE id = $1
   AND book_id = $2
 LIMIT 1
`

type HighlightByIDAndBookParams struct {
	ID     int64
	BookID int64
}

func (q *Queries) HighlightByIDAndBook(ctx context.Context, arg HighlightByIDAndBookParams) (Highlight, error) {
	row := q.db.QueryRowContext(ctx, highlightByIDAndBook, arg.ID, arg.BookID)
	var i Highlight
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Page,
		&i.Content,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const highlights = `-- name: Highlights :many
SELECT id, book_id, page, content, image, created_at, updated_at
  FROM highlights
 WHERE book_id = $1
 ORDER BY page
`

func (q *Queries) Highlights(ctx context.Context, bookID int64) ([]Highlight, error) {
	rows, err := q.db.QueryContext(ctx, highlights, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Highlight
	for rows.Next() {
		var i Highlight
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Page,
			&i.Content,
			&i.Image,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const highlightsWithImages = `-- name: HighlightsWithImages :many
SELECT image
  FROM highlights
 WHERE image IS NOT NULL
   AND length(image) > 0
   AND book_id = $1
`

func (q *Queries) HighlightsWithImages(ctx context.Context, bookID int64) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, highlightsWithImages, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var image sql.NullString
		if err := rows.Scan(&image); err != nil {
			return nil, err
		}
		items = append(items, image)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveBookToShelf = `-- name: MoveBookToShelf :exec
UPDATE books
   SET shelf_id = $1
 WHERE id = $2
`

type MoveBookToShelfParams struct {
	ShelfID sql.NullInt32
	ID      int64
}

func (q *Queries) MoveBookToShelf(ctx context.Context, arg MoveBookToShelfParams) error {
	_, err := q.db.ExecContext(ctx, moveBookToShelf, arg.ShelfID, arg.ID)
	return err
}

const moveShelfDown = `-- name: MoveShelfDown :exec
UPDATE shelves
   SET position = (
     CASE
     WHEN position = (SELECT position FROM shelves WHERE shelves.id = $1) THEN position + 1
     WHEN position = (SELECT position + 1 FROM shelves WHERE shelves.id = $1) THEN position - 1
     END
   )
 WHERE user_id = (SELECT user_id FROM shelves WHERE shelves.id = $1)
   AND position IN (
     (SELECT position FROM shelves WHERE shelves.id = $1),
     (SELECT position + 1 FROM shelves WHERE shelves.id = $1)
   )
`

func (q *Queries) MoveShelfDown(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, moveShelfDown, id)
	return err
}

const moveShelfUp = `-- name: MoveShelfUp :exec
UPDATE shelves
   SET position = (
     CASE
     WHEN position = (SELECT position -1 FROM shelves WHERE shelves.id = $1) THEN position + 1
     WHEN position = (SELECT position FROM shelves WHERE shelves.id = $1) THEN position - 1
     END
   )
 WHERE user_id = (SELECT user_id FROM shelves WHERE shelves.id = $1)
   AND position IN (
     (SELECT position -1 FROM shelves WHERE shelves.id = $1),
     (SELECT position FROM shelves WHERE shelves.id = $1)
   )
`

func (q *Queries) MoveShelfUp(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, moveShelfUp, id)
	return err
}

const newBook = `-- name: NewBook :one
INSERT INTO public.books (title, isbn, author, subtitle, description, publisher, page_count, google_books_id, user_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
       RETURNING id, title, author, image, isbn, created_at, updated_at, shelf_id, user_id, google_books_id, subtitle, description, page_count, publisher
`

type NewBookParams struct {
	Title         string
	Isbn          string
	Author        string
	Subtitle      string
	Description   string
	Publisher     string
	PageCount     int32
	GoogleBooksID sql.NullString
	UserID        int64
}

func (q *Queries) NewBook(ctx context.Context, arg NewBookParams) (Book, error) {
	row := q.db.QueryRowContext(ctx, newBook,
		arg.Title,
		arg.Isbn,
		arg.Author,
		arg.Subtitle,
		arg.Description,
		arg.Publisher,
		arg.PageCount,
		arg.GoogleBooksID,
		arg.UserID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Image,
		&i.Isbn,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShelfID,
		&i.UserID,
		&i.GoogleBooksID,
		&i.Subtitle,
		&i.Description,
		&i.PageCount,
		&i.Publisher,
	)
	return i, err
}

const newHighlight = `-- name: NewHighlight :one
INSERT INTO highlights (book_id, page, content)
VALUES ($1, $2, $3)
       RETURNING id, book_id, page, content, image, created_at, updated_at
`

type NewHighlightParams struct {
	BookID  int64
	Page    int32
	Content string
}

func (q *Queries) NewHighlight(ctx context.Context, arg NewHighlightParams) (Highlight, error) {
	row := q.db.QueryRowContext(ctx, newHighlight, arg.BookID, arg.Page, arg.Content)
	var i Highlight
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Page,
		&i.Content,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const newShelf = `-- name: NewShelf :exec
INSERT INTO public.shelves (name, user_id, position)
VALUES ($1, $2, (
  SELECT coalesce(MAX(position), 0) + 1
    FROM public.shelves
   WHERE user_id = $2)
)
`

type NewShelfParams struct {
	Name   string
	UserID int64
}

func (q *Queries) NewShelf(ctx context.Context, arg NewShelfParams) error {
	_, err := q.db.ExecContext(ctx, newShelf, arg.Name, arg.UserID)
	return err
}

const removeShelf = `-- name: RemoveShelf :exec
UPDATE shelves SET position = position - 1
 WHERE user_id = (SELECT user_id FROM shelves WHERE shelves.id = $1)
   AND position > (SELECT position FROM shelves WHERE shelves.id = $1)
`

func (q *Queries) RemoveShelf(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, removeShelf, id)
	return err
}

const shelfBooks = `-- name: ShelfBooks :many
SELECT books.id id, title, books.image image, google_books_id, slug, isbn
  FROM books, users
 WHERE users.id = books.user_id
   AND shelf_id = $1
 ORDER BY books.created_at DESC
`

type ShelfBooksRow struct {
	ID            int64
	Title         string
	Image         sql.NullString
	GoogleBooksID sql.NullString
	Slug          string
	Isbn          string
}

func (q *Queries) ShelfBooks(ctx context.Context, shelfID sql.NullInt32) ([]ShelfBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, shelfBooks, shelfID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShelfBooksRow
	for rows.Next() {
		var i ShelfBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Image,
			&i.GoogleBooksID,
			&i.Slug,
			&i.Isbn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shelfByIdAndUser = `-- name: ShelfByIdAndUser :one
SELECT id, name, created_at, updated_at, user_id, position
  FROM shelves
 WHERE shelves.user_id = $1
   AND shelves.id = $2
 LIMIT 1
`

type ShelfByIdAndUserParams struct {
	UserID int64
	ID     int64
}

func (q *Queries) ShelfByIdAndUser(ctx context.Context, arg ShelfByIdAndUserParams) (Shelf, error) {
	row := q.db.QueryRowContext(ctx, shelfByIdAndUser, arg.UserID, arg.ID)
	var i Shelf
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Position,
	)
	return i, err
}

const shelves = `-- name: Shelves :many
SELECT id, name, created_at, updated_at, user_id, position
  FROM shelves
 WHERE user_id = $1
 ORDER BY position
`

func (q *Queries) Shelves(ctx context.Context, userID int64) ([]Shelf, error) {
	rows, err := q.db.QueryContext(ctx, shelves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shelf
	for rows.Next() {
		var i Shelf
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signup = `-- name: Signup :one
INSERT
 INTO public.users(name, image, slug, email)
VALUES($1,$2,$3,$4)
       ON CONFLICT (email)
       DO UPDATE SET name = $1, image = $2
       RETURNING id
`

type SignupParams struct {
	Name  sql.NullString
	Image sql.NullString
	Slug  string
	Email sql.NullString
}

func (q *Queries) Signup(ctx context.Context, arg SignupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, signup,
		arg.Name,
		arg.Image,
		arg.Slug,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateBook = `-- name: UpdateBook :exec
UPDATE public.books
   SET title = $1,
       author = $2,
       subtitle = $3,
       description = $4,
       publisher = $5,
       page_count = $6
 WHERE id = $7
`

type UpdateBookParams struct {
	Title       string
	Author      string
	Subtitle    string
	Description string
	Publisher   string
	PageCount   int32
	ID          int64
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) error {
	_, err := q.db.ExecContext(ctx, updateBook,
		arg.Title,
		arg.Author,
		arg.Subtitle,
		arg.Description,
		arg.Publisher,
		arg.PageCount,
		arg.ID,
	)
	return err
}

const updateBookImage = `-- name: UpdateBookImage :exec
UPDATE public.books
   SET image = $1
 WHERE id = $2
`

type UpdateBookImageParams struct {
	Image sql.NullString
	ID    int64
}

func (q *Queries) UpdateBookImage(ctx context.Context, arg UpdateBookImageParams) error {
	_, err := q.db.ExecContext(ctx, updateBookImage, arg.Image, arg.ID)
	return err
}

const updateHighlight = `-- name: UpdateHighlight :exec
UPDATE public.highlights
   SET page = $1,
       content = $2
 WHERE id = $3
`

type UpdateHighlightParams struct {
	Page    int32
	Content string
	ID      int64
}

func (q *Queries) UpdateHighlight(ctx context.Context, arg UpdateHighlightParams) error {
	_, err := q.db.ExecContext(ctx, updateHighlight, arg.Page, arg.Content, arg.ID)
	return err
}

const updateHighlightImage = `-- name: UpdateHighlightImage :exec
UPDATE public.highlights
   SET image = $1
 WHERE id = $2
`

type UpdateHighlightImageParams struct {
	Image sql.NullString
	ID    int64
}

func (q *Queries) UpdateHighlightImage(ctx context.Context, arg UpdateHighlightImageParams) error {
	_, err := q.db.ExecContext(ctx, updateHighlightImage, arg.Image, arg.ID)
	return err
}

const updateShelf = `-- name: UpdateShelf :exec
UPDATE public.shelves
   SET name = $1
 WHERE id = $2
`

type UpdateShelfParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateShelf(ctx context.Context, arg UpdateShelfParams) error {
	_, err := q.db.ExecContext(ctx, updateShelf, arg.Name, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
   SET description = $1,
       amazon_associates_id = $2,
       facebook = $3,
       twitter = $4,
       linkedin = $5,
       instagram = $6,
       phone = $7,
       whatsapp = $8,
       telegram = $9
 WHERE id = $10
`

type UpdateUserParams struct {
	Description        sql.NullString
	AmazonAssociatesID sql.NullString
	Facebook           sql.NullString
	Twitter            sql.NullString
	Linkedin           sql.NullString
	Instagram          sql.NullString
	Phone              sql.NullString
	Whatsapp           sql.NullString
	Telegram           sql.NullString
	ID                 int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Description,
		arg.AmazonAssociatesID,
		arg.Facebook,
		arg.Twitter,
		arg.Linkedin,
		arg.Instagram,
		arg.Phone,
		arg.Whatsapp,
		arg.Telegram,
		arg.ID,
	)
	return err
}

const user = `-- name: User :one
SELECT id, name, email, image, created_at, updated_at, slug, description, facebook, twitter, linkedin, instagram, phone, whatsapp, telegram, amazon_associates_id
  FROM users
 WHERE id = $1
 LIMIT 1
`

func (q *Queries) User(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, user, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.Description,
		&i.Facebook,
		&i.Twitter,
		&i.Linkedin,
		&i.Instagram,
		&i.Phone,
		&i.Whatsapp,
		&i.Telegram,
		&i.AmazonAssociatesID,
	)
	return i, err
}

const userBySlug = `-- name: UserBySlug :one
SELECT id, name, email, image, created_at, updated_at, slug, description, facebook, twitter, linkedin, instagram, phone, whatsapp, telegram, amazon_associates_id
  FROM users
 WHERE slug = $1
 LIMIT 1
`

func (q *Queries) UserBySlug(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRowContext(ctx, userBySlug, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.Description,
		&i.Facebook,
		&i.Twitter,
		&i.Linkedin,
		&i.Instagram,
		&i.Phone,
		&i.Whatsapp,
		&i.Telegram,
		&i.AmazonAssociatesID,
	)
	return i, err
}

const userUnshelvedBooks = `-- name: UserUnshelvedBooks :many
SELECT books.id id, title, books.image image, google_books_id, slug, isbn
  FROM books, users
 WHERE users.id = books.user_id
   AND user_id = $1
   AND shelf_id IS NULL
`

type UserUnshelvedBooksRow struct {
	ID            int64
	Title         string
	Image         sql.NullString
	GoogleBooksID sql.NullString
	Slug          string
	Isbn          string
}

func (q *Queries) UserUnshelvedBooks(ctx context.Context, userID int64) ([]UserUnshelvedBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, userUnshelvedBooks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserUnshelvedBooksRow
	for rows.Next() {
		var i UserUnshelvedBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Image,
			&i.GoogleBooksID,
			&i.Slug,
			&i.Isbn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
